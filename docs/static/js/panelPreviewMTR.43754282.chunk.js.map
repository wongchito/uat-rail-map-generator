{"version":3,"sources":["panels/save/export-diag/mtr-helper.ts"],"names":["readBlobAsDataURL","blob","Promise","resolve","reader","FileReader","onloadend","result","readAsDataURL","getBase64FontFace","svgEl","a","uniqueCharacters","Array","from","Set","querySelectorAll","map","el","innerHTML","join","replace","document","fonts","load","fontFaceList","unicodeRanges","fontFace","unicodeRange","filteredCssRules","querySelector","sheet","cssRules","styleSheet","filter","cssRule","includes","style","all","url","process","src","match","fetch","fontResp","fontDataUri","cssText","console","error"],"mappings":"gOAIMA,EAAoB,SAACC,GACvB,OAAO,IAAIC,SAAQ,SAACC,GAChB,IAAMC,EAAS,IAAIC,WACnBD,EAAOE,UAAY,kBAAMH,EAAQC,EAAOG,SACxCH,EAAOI,cAAcP,OAIhBQ,EAAiB,uCAAG,WAAOC,GAAP,qBAAAC,EAAA,6DACvBC,EAAmBC,MAAMC,KAC3B,IAAIC,IACA,YAAKL,EAAMM,iBAAiB,kBACvBC,KAAI,SAAAC,GAAE,OAAIA,EAAGC,aACbC,KAAK,IACLC,QAAQ,YAAa,MAEhCD,KAAK,IARsB,SAUFE,SAASC,MAAMC,KAAK,mBAAoBZ,GAVtC,cAUvBa,EAVuB,OAWvBC,EAAgBD,EAAaR,KAAI,SAAAU,GAAQ,OAAIA,EAASC,gBAEtDC,EACFhB,MAAMC,KACDQ,SAASQ,cAA+B,kBAAmBC,MAAOC,SAAS,GAAqBC,WAC5FD,UAEXE,QAAO,SAAAC,GAAO,OAAIT,EAAcU,SAAUD,EAAQE,MAAcT,iBAlBrC,SAoBhB1B,QAAQoC,IACjBT,EAAiBZ,IAAjB,uCAAqB,WAAMkB,GAAN,qBAAAxB,EAAA,sEAEP4B,EACFC,mCAAA,UAAuCL,EAAQE,MAAcI,IAAIC,MAAM,6BAAvE,aAAsC,EAAyD,IAHtF,SAIUC,MAAMJ,GAJhB,cAIPK,EAJO,YAKa5C,EALb,SAKqC4C,EAAS3C,OAL9C,kEAKP4C,EALO,yBAMNV,EAAQW,QAAQzB,QAAQ,yBAAxB,oBAA+DwB,EAA/D,UANM,yCAQbE,QAAQC,MAAR,MARa,kBASN,IATM,0DAArB,wDArByB,mFAAH","file":"static/js/panelPreviewMTR.43754282.chunk.js","sourcesContent":["/**\n * Convert a `Blob` into Base64 data URL.\n * @param blob\n */\nconst readBlobAsDataURL = (blob: Blob): Promise<string> => {\n    return new Promise((resolve: (value: string) => void) => {\n        const reader = new FileReader();\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.readAsDataURL(blob);\n    });\n};\n\nexport const getBase64FontFace = async (svgEl: SVGSVGElement): Promise<string[]> => {\n    const uniqueCharacters = Array.from(\n        new Set(\n            [...(svgEl.querySelectorAll('.rmg-name__zh') as NodeListOf<SVGTextElement | SVGTSpanElement>)]\n                .map(el => el.innerHTML)\n                .join('')\n                .replace(/[\\d\\w\\s]/g, '')\n        )\n    ).join('');\n\n    const fontFaceList = await document.fonts.load('80px GenYoMin TW', uniqueCharacters);\n    const unicodeRanges = fontFaceList.map(fontFace => fontFace.unicodeRange); // no duplicated ranges\n\n    const filteredCssRules = (\n        Array.from(\n            (document.querySelector<HTMLLinkElement>('link#css_share')!.sheet!.cssRules[0] as CSSImportRule).styleSheet\n                .cssRules\n        ) as CSSFontFaceRule[]\n    ).filter(cssRule => unicodeRanges.includes((cssRule.style as any).unicodeRange));\n\n    return await Promise.all(\n        filteredCssRules.map(async cssRule => {\n            try {\n                const url =\n                    process.env.PUBLIC_URL + '/styles/' + (cssRule.style as any).src.match(/^url\\(\"([\\S*]+)\"\\)/)?.[1];\n                const fontResp = await fetch(url);\n                const fontDataUri = await readBlobAsDataURL(await fontResp.blob());\n                return cssRule.cssText.replace(/src:[ \\w('\",\\-:/.)]+;/g, `src: url('${fontDataUri}'); `);\n            } catch (err) {\n                console.error(err);\n                return '';\n            }\n        })\n    );\n};\n"],"sourceRoot":""}