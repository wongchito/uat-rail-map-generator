{"version":3,"file":"static/js/runinSHMetro.ea8c7a86.chunk.js","mappings":"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","sources":["svgs/railmap/methods/share.ts","svgs/railmap/methods/shmetro-coline.ts","svgs/runin/runin-shmetro.tsx"],"sourcesContent":["import * as Global from '../../../methods';\nimport { RMGParam, ShortDirection, StationDict, StationInfo } from '../../../constants/constants';\n\n/**\n * Compute the adjacency list of the graph.\n * @param stnList Key-value pairs of station info\n * @param leftW Callback of left wide factor\n * @param rightW Callback of right wide factor\n */\nexport const adjacencyList = (\n    stnList: { [stnId: string]: StationInfo },\n    leftW: (stnList: { [stnId: string]: StationInfo }, stnId: string) => number,\n    rightW: (stnList: { [stnId: string]: StationInfo }, stnId: string) => number\n) => {\n    return Object.keys(stnList).reduce(\n        (acc, cur) => ({\n            ...acc,\n            [cur]: stnList[cur].children.reduce(\n                (a, c) => ({ ...a, [c]: 1 + leftW(stnList, c) + rightW(stnList, cur) }),\n                {}\n            ),\n        }),\n        {} as { [from: string]: { [to: string]: number } }\n    );\n};\n\n/**\n * Compute critical path and its length from `from` node to `to` node with critical path method.\n * @param from ID of station on the left\n * @param to ID of station on the right\n * @param adjMat Adjacency matrix in the form of `Object` returned from `adjacencyList` method.\n */\nexport const criticalPathMethod = (from: string, to: string, adjMat: ReturnType<typeof adjacencyList>) => {\n    if (from === to) {\n        return { len: 0, nodes: [from] };\n    }\n    let allLengths: number[] = [];\n    let criticalPaths: string[][] = [];\n    Object.keys(adjMat[from]).forEach(child => {\n        let cp = criticalPathMethod(child, to, adjMat);\n        if (cp.len < 0) return;\n        allLengths.push(adjMat[from][child] + cp.len);\n        cp.nodes.unshift(from);\n        criticalPaths.push(cp.nodes);\n    });\n    let maxLength = Math.max(...allLengths);\n    return {\n        len: maxLength,\n        nodes: criticalPaths[allLengths.indexOf(maxLength)],\n    };\n};\n\nexport const getXShareMTR = (stnId: string, adjMat: ReturnType<typeof adjacencyList>, branches: string[][]) => {\n    let criticalPath = criticalPathMethod('linestart', 'lineend', adjMat);\n    if (criticalPath.nodes.includes(stnId)) {\n        return criticalPathMethod(criticalPath.nodes[1], stnId, adjMat).len;\n    } else {\n        // must has 1 parent and 1 child only\n        let branchOfStn = branches.filter(branch => branch.includes(stnId))[0];\n\n        let partSource = stnId;\n        while (!criticalPath.nodes.includes(partSource)) {\n            partSource = branchOfStn[branchOfStn.indexOf(partSource) - 1];\n        }\n        let partSink = stnId;\n        while (!criticalPath.nodes.includes(partSink)) {\n            partSink = branchOfStn[branchOfStn.indexOf(partSink) + 1];\n        }\n\n        let leftOpenJaw = partSource === 'linestart';\n        let rightOpenJaw = partSink === 'lineend';\n\n        // expand to fit\n        let lens = [];\n        if (!leftOpenJaw && !rightOpenJaw) {\n            lens[0] = criticalPathMethod(criticalPath.nodes[1], partSource, adjMat).len;\n            lens[1] = criticalPathMethod(partSource, partSink, adjMat).len;\n            lens[2] = criticalPathMethod(partSource, stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, partSink, adjMat).len;\n        } else if (leftOpenJaw) {\n            lens[0] = 0;\n            lens[1] = criticalPathMethod(criticalPath.nodes[1], partSink, adjMat).len;\n            lens[2] = criticalPathMethod(branchOfStn[1], stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, partSink, adjMat).len;\n        } else {\n            // right open jaw\n            lens[0] = criticalPathMethod(criticalPath.nodes[1], partSource, adjMat).len;\n            lens[1] = criticalPathMethod(partSource, criticalPath.nodes.slice(-2)[0], adjMat).len;\n            lens[2] = criticalPathMethod(partSource, stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, branchOfStn.slice(-2)[0], adjMat).len;\n        }\n        return lens[0] + (lens[2] * lens[1]) / (lens[2] + lens[3]);\n    }\n};\n\nconst getYShare = (stnId: string, stnList: { [stnId: string]: StationInfo }) => {\n    return Global.getYShareMTR(stnId, stnList);\n};\n\n/**\n * Vertical position (in pixels) of station icon related to vertical position of line.\n */\nexport const getYReal = (stnId: string, param: RMGParam) => {\n    return -getYShare(stnId, param.stn_list) * param.branch_spacing;\n};\n\nconst _isPredecessor = (stnId1: string, stnId2: string, routes: string[][]) => {\n    for (let route of routes) {\n        let idx1 = route.indexOf(stnId1);\n        let idx2 = route.indexOf(stnId2);\n        if (idx2 !== -1 && idx2 < idx1) return true;\n    }\n    return false;\n};\n\nconst _isSuccessor = (stnId1: string, stnId2: string, routes: string[][]) => {\n    for (let route of routes) {\n        let idx1 = route.indexOf(stnId1);\n        let idx2 = route.indexOf(stnId2);\n        if (idx1 !== -1 && idx1 < idx2) return true;\n    }\n    return false;\n};\n\nexport const getStnState = (\n    currentId: string,\n    routes: string[][],\n    direction: 'l' | 'r'\n): { [stnId: string]: -1 | 0 | 1 } => {\n    console.log(\"computing stations' states\");\n    return [...new Set(([] as string[]).concat(...routes))].reduce(\n        (acc, cur: string) => ({\n            ...acc,\n            [cur]:\n                cur === currentId\n                    ? 0\n                    : (\n                          direction === ShortDirection.right\n                              ? _isSuccessor(currentId, cur, routes)\n                              : _isPredecessor(currentId, cur, routes)\n                      )\n                    ? 1\n                    : -1,\n        }),\n        {}\n    );\n};\n\nexport class Stations {\n    yShares = {} as { [stnId: string]: number };\n    xShares = {} as { [stnId: string]: number };\n    namePoss = {} as { [stnId: string]: boolean };\n    stnList = {} as StationDict;\n    criticalPath = {} as { len: number; nodes: string[] };\n\n    constructor(data: { stnList?: any; criticalPath?: any }) {\n        this.stnList = data.stnList;\n        this.criticalPath = data.criticalPath;\n    }\n\n    /**\n     * Increment of the weight of in-bound edge of a station, which increases the horizontal interval from its parents.\n     */\n    protected leftWideFactor = (stnId: string) => {\n        return 0;\n    };\n\n    /**\n     * Increment of the weight of out-bound edge of a station, which increases the horizontal interval from its children.\n     */\n    protected rightWideFactor = (stnId: string) => {\n        return 0;\n    };\n\n    /**\n     * Path weight from station 1 to station 2 (station 2 must be a child of station 1, otherwise return `-Infinity`).\n     */\n    public pathWeight = (stnId1: string, stnId2: string) => {\n        if (!this.stnList[stnId1].children.includes(stnId2)) {\n            return -Infinity;\n        }\n        return 1 + this.rightWideFactor(stnId1) + this.leftWideFactor(stnId2);\n    };\n\n    protected getYShare(stnId: string, branches?: string[][]): number {\n        if (stnId in this.yShares) return this.yShares[stnId];\n\n        if (\n            ['linestart', 'lineend'].includes(stnId) ||\n            this.stnList[stnId].parents.length > 1 ||\n            this.stnList[stnId].children.length > 1\n        ) {\n            this.yShares[stnId] = 0;\n            return 0;\n        }\n        var stnPred = this.stnList[stnId].parents[0];\n        if (stnPred) {\n            // parent exist\n            if (this.stnList[stnPred].children.length === 1) {\n                // no sibling, then y same as parent\n                let res = this.getYShare(stnPred);\n                this.yShares[stnId] = res;\n                return res;\n            } else {\n                // sibling exists, then y depends on its idx of being children\n                let res: 1 | -1 = this.stnList[stnPred].children.indexOf(stnId) === 0 ? 1 : -1;\n                this.yShares[stnId] = res;\n                return res;\n            }\n        } else {\n            // no parent, must be linestart\n            this.yShares[stnId] = 0;\n            return 0;\n        }\n    }\n\n    static getYShares(stnList: StationDict, branches?: string[][]) {\n        console.log('computing y shares');\n        let stations = new this({ stnList });\n\n        Object.keys(stnList).forEach(stnId => {\n            if (['linestart', 'lineend'].includes(stnId)) return;\n            if (stnId in stations.yShares) return;\n            stations.getYShare(stnId, branches);\n        });\n\n        return stations.yShares;\n    }\n\n    /**\n     * Parameters of the arcs involved in the `<path>` element.\n     */\n    private pathTurnParams = (branchSpacing: number) => {\n        let tr = 35; // turning radius\n        let dx_a = tr / 2; // dx of a\n        let dy_a = tr - dx_a * Math.sqrt(3); // dy of a\n        let dy_l = branchSpacing - 2 * dy_a; // dy of l\n        let dx_l = dy_l * Math.sqrt(3); // dx of l\n        return { tr, dx_a, dy_a, dx_l, dy_l };\n    };\n\n    /**\n     * Path segment from a station towards its southeast (lower-right).\n     */\n    private pathTurnSE = (branchSpacing: number) => {\n        let { tr, dx_a, dy_a, dx_l, dy_l } = this.pathTurnParams(branchSpacing);\n        return `a ${tr},${tr} 0 0,1 ${dx_a},${dy_a} l ${dx_l},${dy_l} a ${tr},${tr} 0 0,0 ${dx_a},${dy_a}`;\n    };\n\n    /**\n     * Path segment from a station towards its northeast (upper-right).\n     */\n    private pathTurnNE = (branchSpacing: number) => {\n        let { tr, dx_a, dy_a, dx_l, dy_l } = this.pathTurnParams(branchSpacing);\n        return `a ${tr},${tr} 0 0,0 ${dx_a},${-dy_a} l ${dx_l},${-dy_l} a ${tr},${tr} 0 0,1 ${dx_a},${-dy_a}`;\n    };\n\n    /**\n     * Generate `d` attribute of `<path>` element through all stations input.\n     */\n    protected _linePath(\n        stnIds: string[],\n        lineXs: [number, number],\n        branches: string[][],\n        realXs: { [stnId: string]: number },\n        realYs: { [stnId: string]: number },\n        branchSpacing: number,\n        cp: { len: number; nodes: string[] },\n        e: number\n    ) {\n        var [prevId, prevY, prevX] = [] as unknown as [string, number, number];\n        var path = [] as string[];\n\n        let { dx_a, dx_l } = this.pathTurnParams(branchSpacing);\n        let stnDX = dx_a + dx_l / 2;\n        let stnExtraH = ((lineXs[1] - lineXs[0]) / cp.len) * 2;\n        let stnSpareH = ((lineXs[1] - lineXs[0]) / cp.len - 2 * stnDX) / 2;\n        if (stnSpareH + stnExtraH < 0) {\n            console.warn(`SVG width too small! ${stnSpareH + stnExtraH}`);\n        }\n\n        stnIds.forEach(stnId => {\n            let x = realXs[stnId];\n            let y = realYs[stnId];\n            if (!prevY && prevY !== 0) {\n                [prevId, prevX, prevY] = [stnId, x, y];\n                if (stnIds.length === 1) {\n                    path.push(`M ${x},${y}`);\n                } else if (!branches[0].includes(stnId)) {\n                    // started from branch\n                    path.push(`M ${x},${y}`);\n                } else if (branches[0].includes(stnIds[1])) {\n                    // started from branching station, this is main line\n                    path.push(`M ${x},${y}`);\n                } else {\n                    // started form branching station, this is branch line\n                    if (realXs[stnIds[1]] > 0) {\n                        path.push(`M ${x},${y + e}`);\n                    }\n                    if (realYs[stnIds[1]] < 0) {\n                        path.push(`M ${x},${y - e}`);\n                    }\n                }\n                return;\n            }\n            if (y > prevY) {\n                path.push(\n                    y === 0\n                        ? `h ${x - prevX - stnExtraH * this.leftWideFactor(stnId) - stnSpareH - stnDX * 2}`\n                        : `h ${stnExtraH * this.rightWideFactor(prevId) + stnSpareH}`\n                );\n                path.push(this.pathTurnSE(branchSpacing));\n            } else if (y < prevY) {\n                path.push(\n                    y === 0\n                        ? `h ${x - prevX - stnExtraH * this.leftWideFactor(stnId) - stnSpareH - stnDX * 2}`\n                        : `h ${stnExtraH * this.rightWideFactor(prevId) + stnSpareH}`\n                );\n                path.push(this.pathTurnNE(branchSpacing));\n            }\n            path.push(`H ${x}`);\n            [prevId, prevX, prevY] = [stnId, x, y];\n        });\n\n        // simplify path\n        return path.join(' ').replace(/( H ([\\d.]+))+/g, ' H $2');\n    }\n\n    static drawLine(\n        branches: string[][],\n        stnStates: { [stnId: string]: -1 | 0 | 1 },\n        stnList: { [stnId: string]: StationInfo },\n        lineXs: [number, number],\n        xs: { [stnId: string]: number },\n        ys: { [stnId: string]: number },\n        branchSpacing: number,\n        cp: { len: number; nodes: string[] },\n        e: number = 9.68\n    ) {\n        let linePaths = { main: [] as string[], pass: [] as string[] };\n        branches.forEach((branch, i) => {\n            branch = branch.filter(stnId => !['linestart', 'lineend'].includes(stnId));\n            var lineMainStns = branch.filter(stnId => stnStates[stnId] >= 0);\n            var linePassStns = branch.filter(stnId => stnStates[stnId] <= 0);\n\n            if (lineMainStns.length === 1) {\n                linePassStns = branch;\n            }\n\n            if (lineMainStns.filter(stnId => linePassStns.indexOf(stnId) !== -1).length === 0 && lineMainStns.length) {\n                // if two set disjoint\n                if (linePassStns[0] === branch[0]) {\n                    // -1 -1 1 1\n                    linePassStns.push(lineMainStns[0]);\n                } else if (\n                    lineMainStns[0] === branch[0] &&\n                    lineMainStns[lineMainStns.length - 1] === branch[branch.length - 1] &&\n                    linePassStns.length\n                ) {\n                    linePassStns = branch;\n                    lineMainStns = [];\n                } else {\n                    // 1 1 -1 -1\n                    linePassStns.unshift(lineMainStns[lineMainStns.length - 1]);\n                }\n            }\n\n            linePaths.main.push(\n                new this({ stnList, criticalPath: cp })._linePath(\n                    lineMainStns,\n                    lineXs,\n                    branches,\n                    xs,\n                    ys,\n                    branchSpacing,\n                    cp,\n                    e\n                )\n            );\n            linePaths.pass.push(\n                new this({ stnList, criticalPath: cp })._linePath(\n                    linePassStns,\n                    lineXs,\n                    branches,\n                    xs,\n                    ys,\n                    branchSpacing,\n                    cp,\n                    e\n                )\n            );\n        });\n\n        return linePaths;\n    }\n}\n\nexport const drawLine = (branch: string[], stnStates: { [stnId: string]: -1 | 0 | 1 }) => {\n    branch = branch.filter(stnId => !['linestart', 'lineend'].includes(stnId));\n    let lineMainStns = branch.filter(stnId => stnStates[stnId] >= 0);\n    let linePassStns = branch.filter(stnId => stnStates[stnId] <= 0);\n\n    if (lineMainStns.length === 1) {\n        linePassStns = branch;\n    }\n\n    if (lineMainStns.filter(stnId => linePassStns.indexOf(stnId) !== -1).length === 0 && lineMainStns.length) {\n        // if two set disjoint\n        if (linePassStns[0] === branch[0]) {\n            // -1 -1 1 1\n            linePassStns.push(lineMainStns[0]);\n        } else if (\n            lineMainStns[0] === branch[0] &&\n            lineMainStns[lineMainStns.length - 1] === branch[branch.length - 1] &&\n            linePassStns.length\n        ) {\n            linePassStns = branch;\n            lineMainStns = [];\n        } else {\n            // 1 1 -1 -1\n            linePassStns.unshift(lineMainStns[lineMainStns.length - 1]);\n        }\n    }\n\n    return {\n        main: lineMainStns,\n        pass: linePassStns,\n    };\n};\n","import { ColineInfo, InterchangeInfo } from '../../../constants/constants';\nimport { drawLine } from './share';\n\nexport interface ColineLinePath {\n    main: {\n        linePath: string[];\n        colors: InterchangeInfo[];\n    }[];\n    pass: {\n        linePath: string[];\n        colors: InterchangeInfo[];\n    }[];\n}\n\n/**\n * Return all stations from ColineInfo's `from` and `to` with coline color preserved.\n */\nexport const calculateColineStations = (colineInfo: ColineInfo[], branches: string[][]) =>\n    colineInfo\n        .map(coLine => {\n            const involvedBranches = branches.filter(\n                branch => branch.includes(coLine.from) && branch.includes(coLine.to)\n            );\n\n            // the current coLineInfo fall on two separate branches,\n            // which should not be possible in current design.\n            if (involvedBranches.length !== 1) return { linePath: [], colors: coLine.colors };\n\n            const branch = involvedBranches.flat();\n            const a = branch.indexOf(coLine.from);\n            const b = branch.indexOf(coLine.to);\n            const linePath = a < b ? branch.slice(a, b + 1) : branch.slice(b, a + 1);\n            return {\n                linePath: linePath,\n                colors: coLine.colors,\n            };\n        })\n        .filter(branchWithColine => branchWithColine.linePath.length !== 0);\n\n/**\n * Return coline segments with stations in main/pass order.\n */\nexport const calculateColine = (\n    branchWithColine: ReturnType<typeof calculateColineStations>,\n    stnStates: {\n        [stnId: string]: 0 | 1 | -1;\n    }\n) =>\n    branchWithColine\n        .map(branchWithColine => {\n            const linePaths = drawLine(branchWithColine.linePath, stnStates);\n            return {\n                main: [\n                    {\n                        linePath: linePaths.main,\n                        colors: branchWithColine.colors,\n                    },\n                ],\n                pass: [\n                    {\n                        linePath: linePaths.pass,\n                        colors: branchWithColine.colors,\n                    },\n                ],\n            };\n        })\n        // .map(branchWithColine =>\n        //     (\n        //         Object.entries(drawLine(branchWithColine.linePath, stnStates)) as [\n        //             keyof ReturnType<typeof drawLine>,\n        //             string[]\n        //         ][]\n        //     )\n        //         .map(([type, linePath]) => ({ [type]: { linePath: linePath, colors: branchWithColine.colors } }))\n        //         .reduce((acc, cur) => ({ ...acc, ...cur }), { main: [], pass: [] } as ColineLinePath)\n        // )\n        .reduce(\n            (acc, cur) => {\n                acc.main = [...acc.main, ...cur.main];\n                acc.pass = [...acc.pass, ...cur.pass];\n                return acc;\n            },\n            { main: [], pass: [] } as ColineLinePath\n        );\n","import React, { useMemo, memo } from 'react';\nimport { Name, StationDict } from '../../constants/constants';\nimport { useAppSelector } from '../../redux';\nimport { isColineBranch } from '../../redux/param/coline-action';\nimport { calculateColineStations } from '../railmap/methods/shmetro-coline';\n\nconst LINE_WIDTH = 12;\n\nconst RunInSHMetro = () => {\n    const { branches, routes, depsStr: deps } = useAppSelector(store => store.helper);\n    const param = useAppSelector(store => store.param);\n\n    // get the height\n    const dh = param.svg_height - 300;\n\n    const prevStnIds = useMemo(\n        () => {\n            let prevStnIds = routes\n                .filter(route => route.includes(param.current_stn_idx))\n                .map(route => route[route.indexOf(param.current_stn_idx) + (param.direction === 'l' ? 1 : -1)])\n                // .flat()\n                // remove duplicate\n                .reduce((acc, cur) => (acc.includes(cur) ? acc : acc.concat(cur)), [] as string[]);\n            if (param.loop && prevStnIds.length === 1 && ['linestart', 'lineend'].includes(prevStnIds[0])) {\n                // if it is a loop and it is the first station of that direction, get the station from the other end\n                prevStnIds = [branches[0][branches[0].length - 2]];\n            }\n            return prevStnIds;\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [deps, param.current_stn_idx, param.direction, param.loop]\n    );\n\n    const nextStnIds = useMemo(\n        () => {\n            let nextStnIds = routes\n                .filter(route => route.includes(param.current_stn_idx))\n                .map(route => route[route.indexOf(param.current_stn_idx) + (param.direction === 'l' ? -1 : 1)])\n                // .flat()\n                // remove duplicate\n                .reduce((acc, cur) => (acc.includes(cur) ? acc : acc.concat(cur)), [] as string[]);\n            if (param.loop && nextStnIds.length === 1 && ['linestart', 'lineend'].includes(nextStnIds[0])) {\n                // if it is a loop and it is the last station of that direction, get the station from the other end\n                nextStnIds = [branches[0][1]];\n            }\n            return nextStnIds;\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [deps, param.current_stn_idx, param.direction, param.loop]\n    );\n\n    return (\n        <>\n            <DefsSHMetro />\n            <g transform={`translate(0,${dh})`}>\n                <GeneralStation prevStnIds={prevStnIds} nextStnIds={nextStnIds} />\n            </g>\n        </>\n    );\n};\n\nexport default RunInSHMetro;\n\nconst DefsSHMetro = memo(() => (\n    <defs>\n        {/* An extension of the line/path. Remember to minus the stroke-width.  */}\n        <marker id=\"slope\" viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n            <path d=\"M0,0L1,1H-1z\" fill=\"var(--rmg-theme-colour)\" />\n        </marker>\n\n        {/* Outline filter of white pass color in Pujiang Line */}\n        <filter\n            id=\"pujiang_outline_runin\"\n            colorInterpolationFilters=\"sRGB\"\n            // TODO: remove the absolute value while make the filter works correctly\n            filterUnits=\"userSpaceOnUse\"\n            x=\"0\"\n            y=\"-1000\"\n            width=\"5000\"\n            height=\"2000\"\n        >\n            <feMorphology operator=\"erode\" in=\"SourceAlpha\" radius=\"0\" result=\"e1\" />\n            <feMorphology operator=\"erode\" in=\"SourceAlpha\" radius=\"1\" result=\"e2\" />\n            <feComposite in=\"e1\" in2=\"e2\" operator=\"xor\" result=\"outline\" />\n            <feComposite in=\"outline\" in2=\"SourceGraphic\" operator=\"over\" result=\"output\" />\n        </filter>\n    </defs>\n));\n\ninterface RunInGeneralProps {\n    prevStnIds: string[];\n    nextStnIds: string[];\n}\n\nconst GeneralStation = (props: RunInGeneralProps) => {\n    const { prevStnIds, nextStnIds } = props;\n    const { info_panel_type, svgWidth, stn_list } = useAppSelector(store => store.param);\n\n    const middle = svgWidth.runin / 2;\n    const terminal = nextStnIds.length === 1 && ['linestart', 'lineend'].includes(nextStnIds[0]);\n    const original = prevStnIds.length === 1 && ['linestart', 'lineend'].includes(prevStnIds[0]);\n\n    const nextNames = nextStnIds.map(stnId => stn_list[stnId].name);\n    const prevNames = prevStnIds.map(stnId => stn_list[stnId].name);\n\n    const nextBranchLineDy =\n        (nextStnIds.length > 1\n            ? (nextNames[0][0].split('\\\\').length - 1) * -50 + (nextNames[0][1].split('\\\\').length - 1) * -30\n            : 0) + 10;\n    const prevBranchLineDy =\n        (prevStnIds.length > 1\n            ? (prevNames[0][0].split('\\\\').length - 1) * -50 + (prevNames[0][1].split('\\\\').length - 1) * -30\n            : 0) + 10;\n\n    return (\n        <>\n            <BranchLine\n                prevStnIds={prevStnIds}\n                nextStnIds={nextStnIds}\n                nextBranchLineDy={nextBranchLineDy}\n                prevBranchLineDy={prevBranchLineDy}\n            />\n\n            {terminal && info_panel_type !== 'sh2020' ? (\n                <TerminalStation mode=\"terminal\" prevStnIds={prevStnIds} nextStnIds={nextStnIds} />\n            ) : original && info_panel_type !== 'sh2020' ? (\n                <TerminalStation mode=\"original\" prevStnIds={prevStnIds} nextStnIds={nextStnIds} />\n            ) : (\n                <>\n                    {/* General Station */}\n                    <Line prevStnIds={prevStnIds} nextStnIds={nextStnIds} />\n\n                    <g transform={`translate(${middle},160)`} textAnchor=\"middle\">\n                        <CurrentText />\n                    </g>\n                </>\n            )}\n\n            {(original || !terminal) && <NextStn stnIds={props.nextStnIds} />}\n            {(terminal || !original) && <PrevStn stnIds={props.prevStnIds} />}\n        </>\n    );\n};\n\nconst TerminalStation = (props: { mode: 'terminal' | 'original'; prevStnIds: string[]; nextStnIds: string[] }) => {\n    const { mode, prevStnIds, nextStnIds } = props;\n    const { current_stn_idx, theme, svgWidth, direction, coline } = useAppSelector(store => store.param);\n    const { branches } = useAppSelector(store => store.helper);\n\n    const textProps = {\n        l: { original: { x: svgWidth.runin - 36, anchor: 'end' }, terminal: { x: 36, anchor: 'start' } },\n        r: { original: { x: 36, anchor: 'start' }, terminal: { x: svgWidth.runin - 36, anchor: 'end' } },\n    };\n\n    const colineStns = calculateColineStations(coline, branches);\n    const nextColineColorFrom = mode === 'terminal' ? prevStnIds : nextStnIds;\n    const nextColineColor =\n        nextStnIds.length > 1\n            ? 'var(--rmg-theme-colour)' // BranchLine will handle color of next line well\n            : colineStns\n                  .filter(co => co.linePath.includes(current_stn_idx) && co.linePath.includes(nextColineColorFrom[0]))\n                  // TODO-coline: handle multiple coline colors\n                  .map(co => co.colors[0][2])[0] ?? 'var(--rmg-theme-colour)';\n\n    return (\n        <>\n            {mode === 'original' && (\n                <path\n                    transform={`translate(0,${coline.length ? '198' : '220'})${coline.length ? 'scale(1,2)' : ''}`}\n                    stroke={nextColineColor}\n                    strokeWidth={12}\n                    d={direction === 'l' ? `M ${svgWidth.runin - 24},16 H 36` : `M24,16 H ${svgWidth.runin - 36}`}\n                    markerEnd=\"url(#slope)\"\n                />\n            )}\n\n            {mode === 'terminal' && (\n                <g filter={theme[2] === '#999999' ? 'url(#pujiang_outline_runin)' : undefined}>\n                    <path\n                        transform={`translate(0,${coline.length ? '198' : '220'})${coline.length ? 'scale(1,2)' : ''}`}\n                        stroke=\"var(--rmg-grey)\"\n                        strokeWidth={12}\n                        d={`M24,16 H ${svgWidth.runin - 24}`}\n                    />\n                </g>\n            )}\n\n            <g\n                transform={`translate(${textProps[direction][mode].x},160)`}\n                textAnchor={textProps[direction][mode].anchor}\n            >\n                <CurrentText />\n            </g>\n        </>\n    );\n};\n\nconst Line = (props: RunInGeneralProps) => {\n    const { prevStnIds, nextStnIds } = props;\n    const {\n        direction,\n        svgWidth,\n        theme,\n        coline,\n        current_stn_idx,\n        stn_list: stnList,\n    } = useAppSelector(store => store.param);\n    const { branches } = useAppSelector(store => store.helper);\n    const middle = svgWidth.runin / 2;\n\n    // determine the end with linestart/lineend or .length === 0\n    const isEnd = (stnIds: string[]) => stnIds.includes('linestart') || stnIds.includes('lineend');\n\n    const colineStns = calculateColineStations(coline, branches);\n\n    // whether the next line is single color(var(--rmg-theme-colour) or coline color) or multiple colors\n    // let nextColineMode: 'single' | 'multiple' = 'single';\n    // TODO-coline: if coline is allowed in other segments, then this should be considered more precisely\n    const nextColineMode =\n        nextStnIds.length > 1\n            ? // needs to be single since BranchLine is in effect\n              'single'\n            : isEnd(nextStnIds)\n            ? colineStns.filter(co => [current_stn_idx, prevStnIds[0]].every(stnId => co.linePath.includes(stnId)))\n                  .length > 0\n                ? // if this the terminal station, look back to see if it falls in coline\n                  'multiple'\n                : 'single'\n            : [current_stn_idx, nextStnIds[0]].every(stnId => branches[0].includes(stnId)) && // is in the main line\n              // and has coline from current_stn_idx to nextStnIds[0]\n              colineStns.filter(co => [current_stn_idx, nextStnIds[0]].every(stnId => co.linePath.includes(stnId)))\n                  .length > 0\n            ? 'multiple'\n            : 'single';\n\n    const nextColineColorFrom = isEnd(nextStnIds) ? prevStnIds : nextStnIds;\n    const nextColineColor =\n        nextStnIds.length > 1\n            ? 'var(--rmg-theme-colour)' // BranchLine will handle color of next line well\n            : colineStns\n                  .filter(co => co.linePath.includes(current_stn_idx) && co.linePath.includes(nextColineColorFrom[0]))\n                  // TODO-coline: handle multiple coline colors\n                  .map(co => co.colors[0][2])[0] ?? 'var(--rmg-theme-colour)';\n\n    // curr and next/pass segment is in the coline branch\n    const isInColineBranch = (\n        branches: string[][],\n        current_stn_idx: string,\n        nextOrPassStnIds: string[],\n        stnList: StationDict\n    ) =>\n        branches\n            .slice(1)\n            .filter(branch => [current_stn_idx, nextOrPassStnIds[0]].every(stnId => branch.includes(stnId)))\n            .filter(branch => isColineBranch(branch, stnList)).length > 0;\n\n    // change color to coline color only if it has coline and the curr and next stations are in the coline branch\n    const nextColor =\n        coline.length > 0 && isInColineBranch(branches, current_stn_idx, nextStnIds, stnList)\n            ? nextColineColor\n            : 'var(--rmg-theme-colour)';\n\n    // stretch the next line element if curr and next stations aren't in main line with coline\n    const nextLineStretch =\n        coline.length > 0 &&\n        nextStnIds.length === 1 && // BranchLine will add branch next line so no stretch is needed\n        (isEnd(prevStnIds) || isEnd(nextStnIds)\n            ? true // terminal station with coline(prevent linestart/lineend)\n            : !(\n                  [current_stn_idx, nextStnIds[0]].every(stnId => branches[0].includes(stnId)) &&\n                  colineStns.filter(co => co.linePath.includes(current_stn_idx) && co.linePath.includes(nextStnIds[0]))\n                      .length !== 0\n              )); // no stretch if it is in main line with coline\n\n    // stretch the pass line element if BranchLine is not in effect\n    const passLineStretch = coline.length > 0 && prevStnIds.length === 1;\n\n    return (\n        <g transform=\"translate(0,220)\" strokeWidth={12}>\n            <>\n                {nextColor !== 'var(--rmg-theme-colour)' && (\n                    <marker id={`slope_${nextColor}`} viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n                        <path d=\"M0,0L1,1H-1z\" fill={nextColor} />\n                    </marker>\n                )}\n                <path\n                    stroke={nextColor}\n                    d={`M ${middle},16 H ${direction === 'l' ? 36 : svgWidth.runin - 36}`}\n                    // markerEnd=\"url(#slope)\"\n                    markerEnd={nextColor === 'var(--rmg-theme-colour)' ? 'url(#slope)' : `url(#slope_${nextColor})`}\n                    transform={nextLineStretch ? 'translate(0,-22)scale(1,2)' : undefined}\n                />\n            </>\n            {nextColineMode === 'multiple' && (\n                <>\n                    <marker id={`slope_${nextColineColor}`} viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n                        <path d=\"M0,0L1,1H-1z\" fill={nextColineColor} />\n                    </marker>\n                    <path\n                        stroke={nextColineColor}\n                        d={`M ${middle},16 H ${\n                            direction === 'l' ? 36 + LINE_WIDTH : svgWidth.runin - (36 + LINE_WIDTH)\n                        }`}\n                        markerEnd={`url(#slope_${nextColineColor})`}\n                        transform=\"translate(0,-12)\"\n                    />\n                </>\n            )}\n\n            <g\n                filter={theme[2] === '#999999' ? 'url(#pujiang_outline_runin)' : undefined}\n                transform={`translate(0,${passLineStretch ? -22 : 0})scale(1,${passLineStretch ? 2 : 1})`}\n            >\n                <path\n                    stroke=\"var(--rmg-grey)\"\n                    d={`M ${middle},16 H ${direction === 'l' ? svgWidth.runin - 24 : 24} `}\n                />\n            </g>\n        </g>\n    );\n};\n\ninterface RunInBranchLineProps {\n    prevStnIds: string[];\n    nextStnIds: string[];\n    nextBranchLineDy: number;\n    prevBranchLineDy: number;\n}\n\nconst BranchLine = (props: RunInBranchLineProps) => {\n    const { prevStnIds, nextStnIds, nextBranchLineDy, prevBranchLineDy } = props;\n\n    const { direction, svgWidth, current_stn_idx, coline, theme } = useAppSelector(store => store.param);\n    const { branches } = useAppSelector(store => store.helper);\n    const middle = svgWidth.runin / 2;\n\n    const LINE_BRANCH_Y = 125;\n\n    // draw a line between these dots\n    const dotToPos = (dot: [number, number]) => `${dot[0]},${dot[1]}`;\n    const dotsToPath = (dots: [number, number][]) =>\n        `M${dotToPos(dots.at(0)!)} ` +\n        dots\n            .slice(1)\n            .map(dot => `L${dotToPos(dot)}`)\n            .join(' ');\n\n    let nextDots = (\n        direction === 'l'\n            ? [\n                  [svgWidth.runin / 3, LINE_BRANCH_Y],\n                  [svgWidth.runin / 6, nextBranchLineDy],\n                  [36, nextBranchLineDy],\n              ]\n            : [\n                  [(svgWidth.runin / 3) * 2, LINE_BRANCH_Y],\n                  [(svgWidth.runin / 6) * 5, nextBranchLineDy],\n                  [svgWidth.runin - 36, nextBranchLineDy],\n              ]\n    ) as [number, number][];\n    let prevDots = (\n        direction === 'l'\n            ? [\n                  [(svgWidth.runin / 3) * 2, LINE_BRANCH_Y],\n                  [(svgWidth.runin / 6) * 5, prevBranchLineDy],\n                  [svgWidth.runin - 24, prevBranchLineDy],\n              ]\n            : [\n                  [svgWidth.runin / 3, LINE_BRANCH_Y],\n                  [svgWidth.runin / 6, prevBranchLineDy],\n                  [24, prevBranchLineDy],\n              ]\n    ) as [number, number][];\n\n    let nextColor = 'var(--rmg-theme-colour)';\n\n    if (coline.length > 0) {\n        const colineStns = calculateColineStations(coline, branches);\n\n        // If the next stns have coline branch here,\n        // uplift branch a little bit with coline color.\n        if (\n            nextStnIds.length > 1 &&\n            colineStns.filter(\n                stns =>\n                    stns.linePath.includes(current_stn_idx) && nextStnIds.some(stnId => stns.linePath.includes(stnId))\n            )\n        ) {\n            // no idea why strokeWidth is 12 but only when dy = -11 will be perfect\n            nextDots[0][1] -= LINE_WIDTH - 1;\n            nextDots.unshift([middle, LINE_BRANCH_Y - LINE_WIDTH + 1]);\n            nextColor = colineStns\n                .filter(\n                    stns =>\n                        stns.linePath.includes(current_stn_idx) &&\n                        nextStnIds.some(stnId => stns.linePath.includes(stnId))\n                )\n                // TODO-coline: known undefined issues when coline is removed if the station is removed via removeInvalidColineOnRemoveStation\n                .at(0)!\n                .colors.at(0)![2];\n        }\n\n        // If the prev stns have coline branch here,\n        // uplift branch a little bit.\n        if (\n            prevStnIds.length > 1 &&\n            colineStns.filter(\n                stns =>\n                    stns.linePath.includes(current_stn_idx) && prevStnIds.some(stnId => stns.linePath.includes(stnId))\n            )\n        ) {\n            // no idea why strokeWidth is 12 but only when dy = -11 will be perfect\n            prevDots[0][1] -= LINE_WIDTH - 1;\n            prevDots.unshift([middle, LINE_BRANCH_Y - LINE_WIDTH + 1]);\n        }\n    }\n\n    return (\n        <g\n            transform=\"translate(0,110)\"\n            strokeWidth={12}\n            fill=\"none\"\n            filter={theme[2] === '#999999' ? 'url(#pujiang_outline_runin)' : undefined}\n        >\n            {/* An extension of the line/path with coline color. */}\n            <marker id=\"slope_branch\" viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n                <path d=\"M0,0L1,1H-1z\" fill={nextColor} />\n            </marker>\n\n            {nextStnIds.length > 1 && (\n                <path stroke={nextColor} d={dotsToPath(nextDots)} markerEnd=\"url(#slope_branch)\" />\n            )}\n            {prevStnIds.length > 1 && <path stroke=\"var(--rmg-grey)\" d={dotsToPath(prevDots)} />}\n        </g>\n    );\n};\n\nconst CurrentText = () => {\n    const param = useAppSelector(store => store.param);\n    const { name } = param.stn_list[param.current_stn_idx];\n    return useMemo(\n        () => (\n            <>\n                <text className=\"rmg-name__zh\" fontSize={112}>\n                    {name[0]}\n                </text>\n                <text className=\"rmg-name__en\" fontSize={36} dy={50}>\n                    {name[1].replace('\\\\', ' ')}\n                </text>\n            </>\n        ),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [...name]\n    );\n};\n\nconst NextText = (props: { nextName: Name } & React.SVGProps<SVGGElement>) => {\n    const { nextName, ...others } = props;\n    return (\n        <g {...others}>\n            {useMemo(\n                () => (\n                    <>\n                        {nextName[0].split('\\\\').map((name, i, array) => (\n                            <text\n                                className=\"rmg-name__zh\"\n                                fontSize={48}\n                                key={name}\n                                dy={(array.length - 1 - i) * -50 - (nextName[1].split('\\\\').length - 1) * 30}\n                            >\n                                {name}\n                            </text>\n                        ))}\n                        {nextName[1].split('\\\\').map((name, i, array) => (\n                            <text\n                                className=\"rmg-name__en\"\n                                fontSize={24}\n                                key={name}\n                                dy={28 + (array.length - 1 - i) * -30}\n                            >\n                                {name}\n                            </text>\n                        ))}\n                    </>\n                ),\n                // eslint-disable-next-line react-hooks/exhaustive-deps\n                [...nextName]\n            )}\n        </g>\n    );\n};\n\nconst PrevStn = (props: { stnIds: string[] }) => {\n    const param = useAppSelector(store => store.param);\n    const nextNames = props.stnIds.map(stnId => param.stn_list[stnId].name);\n    const prevHintDy =\n        (props.stnIds.length > 1 ? 15 : 125) +\n        nextNames.map(name => name[0].split('\\\\').length).reduce((acc, cur) => acc + cur, -nextNames.length) * -50 +\n        nextNames.map(name => name[1].split('\\\\').length).reduce((acc, cur) => acc + cur, -nextNames.length) * -30;\n    const nextBranchTextDy =\n        (props.stnIds.length > 1\n            ? (nextNames[0][0].split('\\\\').length - 1) * -50 + (nextNames[0][1].split('\\\\').length - 1) * -30\n            : 0) + 70;\n\n    return (\n        <g\n            fill=\"gray\"\n            textAnchor={param.direction === 'l' ? 'end' : 'start'}\n            transform={`translate(${param.direction === 'l' ? param.svgWidth.runin - 36 : 36},0)`}\n        >\n            <NextText nextName={nextNames[0]} transform=\"translate(0,183)\" />\n            {props.stnIds.length > 1 && (\n                <NextText nextName={nextNames[1]} transform={`translate(0,${nextBranchTextDy})`} />\n            )}\n            <g transform={`translate(0, ${prevHintDy})`}>\n                <text className=\"rmg-name__zh\" fontSize={22}>\n                    上一站\n                </text>\n                <text className=\"rmg-name__en\" fontSize={12} dx={param.direction === 'l' ? -70 : 70}>\n                    Past Stop\n                </text>\n            </g>\n        </g>\n    );\n};\n\nconst NextStn = (props: { stnIds: string[] }) => {\n    const param = useAppSelector(store => store.param);\n    const nextNames = props.stnIds.map(stnId => param.stn_list[stnId].name);\n    const nextHintDy =\n        (props.stnIds.length > 1 ? 15 : 125) +\n        nextNames.map(name => name[0].split('\\\\').length).reduce((acc, cur) => acc + cur, -nextNames.length) * -50 +\n        nextNames.map(name => name[1].split('\\\\').length).reduce((acc, cur) => acc + cur, -nextNames.length) * -30;\n    const nextBranchTextDy =\n        (props.stnIds.length > 1\n            ? (nextNames[0][0].split('\\\\').length - 1) * -50 + (nextNames[0][1].split('\\\\').length - 1) * -30\n            : 0) + 70;\n\n    return (\n        <g\n            textAnchor={param.direction === 'l' ? 'start' : 'end'}\n            transform={`translate(${param.direction === 'l' ? 36 : param.svgWidth.runin - 36},0)`}\n        >\n            <NextText nextName={param.stn_list[props.stnIds[0]].name} transform=\"translate(0,183)\" />\n            {props.stnIds.length > 1 && (\n                <NextText\n                    nextName={param.stn_list[props.stnIds[1]].name}\n                    transform={`translate(0,${nextBranchTextDy})`}\n                />\n            )}\n            <g transform={`translate(0, ${nextHintDy})`}>\n                <text className=\"rmg-name__zh\" fontSize={22}>\n                    下一站\n                </text>\n                <text className=\"rmg-name__en\" fontSize={12} dx={param.direction === 'l' ? 70 : -70}>\n                    Next Stop\n                </text>\n            </g>\n        </g>\n    );\n};\n"],"names":["adjacencyList","stnList","leftW","rightW","Object","keys","reduce","acc","cur","children","a","c","criticalPathMethod","from","to","adjMat","len","nodes","allLengths","criticalPaths","forEach","child","cp","push","unshift","maxLength","Math","max","indexOf","getXShareMTR","stnId","branches","criticalPath","includes","branchOfStn","filter","branch","partSource","partSink","leftOpenJaw","lens","slice","getStnState","currentId","routes","direction","console","log","Set","concat","ShortDirection","stnId1","stnId2","route","idx1","idx2","_isSuccessor","_isPredecessor","Stations","data","yShares","xShares","namePoss","leftWideFactor","rightWideFactor","pathWeight","Infinity","pathTurnParams","branchSpacing","dy_a","tr","sqrt","dy_l","dx_a","dx_l","pathTurnSE","pathTurnNE","this","parents","length","stnPred","res","getYShare","stnIds","lineXs","realXs","realYs","e","prevId","prevY","prevX","path","stnDX","stnExtraH","stnSpareH","warn","x","y","join","replace","stations","stnStates","xs","ys","linePaths","main","pass","i","lineMainStns","linePassStns","_linePath","drawLine","calculateColineStations","colineInfo","map","coLine","involvedBranches","linePath","colors","flat","b","branchWithColine","calculateColine","useAppSelector","store","helper","deps","depsStr","param","dh","svg_height","prevStnIds","useMemo","current_stn_idx","loop","nextStnIds","DefsSHMetro","transform","GeneralStation","memo","id","viewBox","refY","d","fill","colorInterpolationFilters","filterUnits","width","height","operator","in","radius","result","in2","props","info_panel_type","svgWidth","stn_list","middle","runin","terminal","original","nextNames","name","prevNames","nextBranchLineDy","split","prevBranchLineDy","BranchLine","TerminalStation","mode","Line","textAnchor","CurrentText","NextStn","PrevStn","theme","coline","textProps","l","anchor","r","colineStns","nextColineColorFrom","nextColineColor","co","stroke","strokeWidth","markerEnd","undefined","isEnd","nextColineMode","every","nextColor","nextOrPassStnIds","isColineBranch","isInColineBranch","nextLineStretch","passLineStretch","LINE_BRANCH_Y","dotToPos","dot","dotsToPath","dots","at","nextDots","prevDots","stns","some","LINE_WIDTH","className","fontSize","dy","NextText","nextName","others","array","prevHintDy","nextBranchTextDy","dx","nextHintDy"],"sourceRoot":""}