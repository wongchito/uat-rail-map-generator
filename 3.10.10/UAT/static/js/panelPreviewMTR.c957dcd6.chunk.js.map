{"version":3,"sources":["panels/save/export-diag/mtr-helper.ts"],"names":["getRFFHelper","char","charForm","a","document","fonts","load","f","styleEl","querySelector","styleSheet","sheet","cssText","cssRules","find","cssRule","includes","unicodeRange","Error","getRenderedFontFace","Promise","allSettled","results","rules","reduce","acc","res","status","concat","value","length","console","warn","readBlobAsDataURL","blob","resolve","reader","FileReader","onloadend","result","readAsDataURL","getBase64FontFace","svgEl","fetch","response","text","s","createElement","id","textContent","head","prepend","distinctCharList","Set","querySelectorAll","map","el","innerHTML","join","replace","all","remove","rule","match","fontResp","fontDataUri"],"mappings":"wOAQMA,EAAY,uCAAG,WAAOC,EAAcC,GAArB,2BAAAC,EAAA,sEACCC,SAASC,MAAMC,KAAK,mBAAqBJ,EAAUD,GADpD,wCACVM,EADU,0BAGPC,EAAUJ,SAASK,cAAgC,qBACnDC,EAAaF,EAASG,QACtBC,EALO,UAKG,YAAIF,EAAYG,UAAUC,MAAK,SAAAC,GAC3C,IAAMH,EAAUG,EAAQH,QACxB,OAAOA,EAAQI,SAAS,cAAgBd,IAAaU,EAAQI,SAAST,EAAEU,wBAP/D,aAKG,EAGZL,SARS,0CAUFA,GAVE,cAcXM,MAAM,gBAAD,OAAiBjB,EAAjB,4BAAyCC,IAdnC,4CAAH,wDAqBZiB,EAAmB,uCAAG,WAAOlB,GAAP,iBAAAE,EAAA,yDACX,WAATF,EADoB,gCAEPD,EAAaC,EAAM,MAFZ,uFAMPD,EAAaC,EAAM,MANZ,6DASHD,EAAaC,EAAM,MAThB,oDAYMmB,QAAQC,WAAW,CAACrB,EAAaC,EAAM,MAAOD,EAAaC,EAAM,QAZvE,eAYVqB,EAZU,QAaVC,EAAQD,EAAQE,QAClB,SAACC,EAAKC,GAAN,MAA8B,cAAfA,EAAIC,OAAyBF,EAAIG,OAAOF,EAAIG,OAASJ,IACpE,KAEOK,QACPC,QAAQC,KAAK/B,EAAO,eAlBR,kBAoBTsB,GApBS,kEAAH,sDA6BnBU,EAAoB,SAACC,GACvB,OAAO,IAAId,SAAQ,SAACe,GAChB,IAAMC,EAAS,IAAIC,WACnBD,EAAOE,UAAY,kBAAMH,EAAQC,EAAOG,SACxCH,EAAOI,cAAcN,OAQhBO,EAAiB,uCAAG,WAAOC,GAAP,yBAAAvC,EAAA,+EAEFwC,MACnB,kIAHqB,cAEnBC,EAFmB,gBAMHA,EAASC,OANN,cAMnBjC,EANmB,QAQnBkC,EAAI1C,SAAS2C,cAAc,UAC/BC,GAAK,cACPF,EAAEG,YAAcrC,EAChBR,SAAS8C,KAAKC,QAAQL,GAEhBM,EAbmB,YAclB,IAAIC,IACH,YAAKX,EAAMY,iBAAiB,kBACvBC,KAAI,SAAAC,GAAE,OAAIA,EAAGC,aACbC,KAAK,IACLC,QAAQ,YAAa,MAlBT,UAsBLvC,QAAQwC,IAAIR,EAAiBG,IAAIpC,IAtB5B,eAsBnBI,EAtBmB,OAuBzBuB,EAAEe,SAvBuB,UAyBZzC,QAAQwC,IACjB,YAAI,IAAIP,KAAK,MAAgBzB,OAAjB,oBAA2BL,MAASgC,IAAhD,uCAAoD,WAAMO,GAAN,iBAAA3D,EAAA,+EAErBwC,MAAMmB,EAAKC,MAAM,0BAA2B,IAFvB,cAEtCC,EAFsC,YAGlB/B,EAHkB,SAGM+B,EAAS9B,OAHf,kEAGtC+B,EAHsC,yBAIrCH,EAAKH,QAAQ,yBAAb,oBAAoDM,EAApD,UAJqC,yCAM5ClC,QAAQC,KAAR,MAN4C,kBAOrC,IAPqC,0DAApD,wDA1BqB,gJAAH","file":"static/js/panelPreviewMTR.c957dcd6.chunk.js","sourcesContent":["// This helper util is not in used at the moment.\n// It may be reused when we allow users to select full set of fonts or web font chunks for exported SVG.\n\n/**\n * Helper function for filtering out the `CSSFontFaceRule` which renders the input character by matching character form and unicode range.\n * @param char string with one Chinese character\n * @param charForm code indicating country-variant Noto Serif font\n */\nconst getRFFHelper = async (char: string, charForm: 'SC' | 'TC' | 'JP' | 'KR'): Promise<string> => {\n    const [f] = await document.fonts.load('80px Noto Serif ' + charForm, char);\n    if (f) {\n        const styleEl = document.querySelector<HTMLStyleElement>('style#googlefonts');\n        const styleSheet = styleEl!.sheet;\n        const cssText = [...styleSheet!.cssRules].find(cssRule => {\n            const cssText = cssRule.cssText;\n            return cssText.includes('Noto Serif ' + charForm) && cssText.includes(f.unicodeRange);\n        })?.cssText;\n        if (cssText) {\n            return cssText;\n        }\n    }\n\n    throw Error(`Can't render ${char} with Noto Serif ${charForm}`);\n};\n\n/**\n * Get `cssText` of `CSSFontFaceRule` which renders the input character.\n * @param char string with one Chinese character\n */\nconst getRenderedFontFace = async (char: string): Promise<string[] | string> => {\n    if (char === 'é—¨') {\n        return await getRFFHelper(char, 'SC');\n    }\n\n    try {\n        return await getRFFHelper(char, 'KR');\n    } catch (_) {\n        try {\n            return await getRFFHelper(char, 'JP');\n        } catch (_) {\n            // Render with TC and SC together due to weird response\n            const results = await Promise.allSettled([getRFFHelper(char, 'TC'), getRFFHelper(char, 'SC')]);\n            const rules = results.reduce(\n                (acc, res) => (res.status === 'fulfilled' ? acc.concat(res.value) : acc),\n                [] as string[]\n            );\n            if (!rules.length) {\n                console.warn(char + ': not found');\n            }\n            return rules;\n        }\n    }\n};\n\n/**\n * Convert a `Blob` into Base64 data URL.\n * @param blob\n */\nconst readBlobAsDataURL = (blob: Blob): Promise<string> => {\n    return new Promise((resolve: (value: string) => void) => {\n        const reader = new FileReader();\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.readAsDataURL(blob);\n    });\n};\n\n/**\n * Get `CSSFontFaceRule` whose source is Base64 URL for all Chinese characters in a `SVGSVGElement`.\n * @param svgEl `SVGSVGElement` to be exported\n */\nexport const getBase64FontFace = async (svgEl: SVGSVGElement): Promise<string[]> => {\n    try {\n        const response = await fetch(\n            'https://fonts.googleapis.com/css' +\n                '?family=Noto+Serif+KR:600|Noto+Serif+JP:600|Noto+Serif+TC:600|Noto+Serif+SC:600%26display=swap'\n        );\n        const cssText = await response.text(); // constructed with multiple @font-face\n\n        const s = document.createElement('style');\n        s.id = 'googlefonts';\n        s.textContent = cssText;\n        document.head.prepend(s);\n\n        const distinctCharList = [\n            ...new Set(\n                [...(svgEl.querySelectorAll('.rmg-name__zh') as NodeListOf<SVGTextElement | SVGTSpanElement>)]\n                    .map(el => el.innerHTML)\n                    .join('')\n                    .replace(/[\\d\\w\\s]/g, '')\n            ),\n        ];\n\n        const rules = await Promise.all(distinctCharList.map(getRenderedFontFace));\n        s.remove();\n\n        return await Promise.all(\n            [...new Set(([] as string[]).concat(...rules))].map(async rule => {\n                try {\n                    const fontResp = await fetch(rule.match(/https:[\\w:/.-]+.woff2/g)![0]);\n                    const fontDataUri = await readBlobAsDataURL(await fontResp.blob());\n                    return rule.replace(/src:[ \\w('\",\\-:/.)]+;/g, `src: url('${fontDataUri}'); `);\n                } catch (err) {\n                    console.warn(err);\n                    return '';\n                }\n            })\n        );\n    } catch (err) {\n        throw err;\n    }\n};\n"],"sourceRoot":""}