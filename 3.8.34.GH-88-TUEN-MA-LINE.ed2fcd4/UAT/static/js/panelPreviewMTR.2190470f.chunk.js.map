{"version":3,"sources":["panels/save/export-diag/mtr-helper.ts"],"names":["getRFFHelper","char","charForm","a","document","fonts","load","f","querySelector","sheet","cssRules","rule","cssText","includes","unicodeRange","Error","getRenderedFontFace","Promise","resolve","catch","allSettled","results","rules","reduce","acc","res","status","concat","value","length","console","warn","readBlobAsDataURL","blob","reader","FileReader","onloadend","result","readAsDataURL","getBase64FontFace","svgEl","fetch","then","response","text","csstext","s","createElement","type","id","textContent","head","append","txt","Set","querySelectorAll","map","el","innerHTML","join","replace","all","remove","match","uri","err"],"mappings":"qOAKMA,EAAY,uCAAG,WAAOC,EAAcC,GAArB,yBAAAC,EAAA,sEACCC,SAASC,MAAMC,KAAK,mBAAqBJ,EAAUD,GADpD,wCACVM,EADU,yCAIJH,SAASI,cAAc,qBAA0CC,MAAwBC,UAJrF,8CAGJC,EAHI,MAMAC,QAAQC,SAAS,cAAgBX,KAAaS,EAAKC,QAAQC,SAASN,EAAEO,cANtE,0CAOEH,EAAKC,SAPP,yCASXG,MAAM,gBAAD,OAAiBd,EAAjB,4BAAyCC,IATnC,4CAAH,wDAgBZc,EAAmB,uCAAG,WAAOf,GAAP,SAAAE,EAAA,yDACX,WAATF,EADoB,yCACCD,EAAaC,EAAM,OADpB,gCAGjBgB,QAAQC,QAAQlB,EAAaC,EAAM,OAAOkB,OAAM,kBACnDF,QAAQC,QAAQlB,EAAaC,EAAM,OAAOkB,MAA1C,sBAAgD,8BAAAhB,EAAA,sEAEtBc,QAAQG,WAAW,CAACpB,EAAaC,EAAM,MAAOD,EAAaC,EAAM,QAF3C,cAEtCoB,EAFsC,QAGxCC,EAAQD,EAAQE,QAChB,SAACC,EAAKC,GAAN,MAA8B,cAAfA,EAAIC,OAAyBF,EAAIG,OAAOF,EAAIG,OAASJ,IACpE,KAEOK,QAAQC,QAAQC,KAAK9B,EAAO,eAPK,kBAQrCqB,GARqC,gDAJ5B,2CAAH,sDA+BnBU,EAAoB,SAACC,GAAD,OACtB,IAAIhB,SAAQ,SAACC,GACT,IAAIgB,EAAS,IAAIC,WACjBD,EAAOE,UAAY,kBAAMlB,EAAQgB,EAAOG,SACxCH,EAAOI,cAAcL,OAOhBM,EAAoB,SAACC,GAAD,OAC7BC,MACI,kIAECC,MAAK,SAAAC,GAAQ,OAAIA,EAASC,UAC1BF,KAJL,uCAIU,WAAMG,GAAN,qBAAA1C,EAAA,6DACE2C,EAAI1C,SAAS2C,cAAc,UAC7BC,KAAO,WACTF,EAAEG,GAAK,cACPH,EAAEI,YAAcL,EAChBzC,SAAS+C,KAAKC,OAAON,GAEjBO,EAPF,YAQK,IAAIC,IACH,YAAKd,EAAMe,iBAAiB,kBACvBC,KAAI,SAAAC,GAAE,OAAIA,EAAGC,aACbC,KAAK,IACLC,QAAQ,YAAa,MAZhC,SAgBgB3C,QAAQ4C,IAAIR,EAAIG,IAAIxC,IAhBpC,cAgBEM,EAhBF,OAiBFwB,EAAEgB,SAjBA,kBAmBK,YAAI,IAAIR,KAAK,MAAgB3B,OAAjB,oBAA2BL,MAASkC,KAAI,SAAA7C,GAAI,OAC3D8B,MAAM9B,EAAKoD,MAAM,0BAA2B,IACvCrB,MAAK,SAAAC,GAAQ,OAAIA,EAASV,UAC1BS,KAAKV,GACLU,MAAK,SAAAsB,GAAG,OAAIrD,EAAKiD,QAAQ,yBAAb,oBAAoDI,EAApD,YACZ7C,OAAM,SAAA8C,GAEH,OADAnC,QAAQC,KAAKkC,GACN,UA1BjB,4CAJV","file":"static/js/panelPreviewMTR.2190470f.chunk.js","sourcesContent":["/**\n * Helper function for filtering out the `CSSFontFaceRule` which renders the input character by matching character form and unicode range.\n * @param char string with one Chinese character\n * @param charForm code indicating country-variant Noto Serif font\n */\nconst getRFFHelper = async (char: string, charForm: 'SC' | 'TC' | 'JP' | 'KR') => {\n    const [f] = await document.fonts.load('80px Noto Serif ' + charForm, char);\n    if (f)\n        for (let rule of [\n            ...((document.querySelector('style#googlefonts') as HTMLStyleElement).sheet as CSSStyleSheet).cssRules,\n        ])\n            if (rule.cssText.includes('Noto Serif ' + charForm) && rule.cssText.includes(f.unicodeRange))\n                return rule.cssText;\n\n    throw Error(`Can't render ${char} with Noto Serif ${charForm}`);\n};\n\n/**\n * Get `cssText` of `CSSFontFaceRule` which renders the input character.\n * @param char string with one Chinese character\n */\nconst getRenderedFontFace = async (char: string): Promise<string[] | string> => {\n    if (char === 'é—¨') return getRFFHelper(char, 'SC');\n\n    return Promise.resolve(getRFFHelper(char, 'KR')).catch(() =>\n        Promise.resolve(getRFFHelper(char, 'JP')).catch(async () => {\n            // Render with TC and SC together due to weird response\n            const results = await Promise.allSettled([getRFFHelper(char, 'TC'), getRFFHelper(char, 'SC')]);\n            let rules = results.reduce(\n                (acc, res) => (res.status === 'fulfilled' ? acc.concat(res.value) : acc),\n                [] as string[]\n            );\n            if (!rules.length) console.warn(char + ': not found');\n            return rules;\n        })\n    );\n    // return Promise.all([getRFFHelper(char, 'KR')]).catch(() =>\n    //     Promise.all([getRFFHelper(char, 'JP')]).catch(() =>\n    //         Promise.all([getRFFHelper(char, 'TC'), getRFFHelper(char, 'SC')]).catch(() =>\n    //             Promise.all([getRFFHelper(char, 'SC')]).catch(() => {\n    //                 console.warn(char + ': not found');\n    //                 return [];\n    //             })\n    //         )\n    //     )\n    // );\n};\n\n/**\n * Convert a `Blob` into Base64 data URL.\n * @param blob\n */\nconst readBlobAsDataURL = (blob: Blob) =>\n    new Promise((resolve: (value: string) => void) => {\n        let reader = new FileReader();\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.readAsDataURL(blob);\n    });\n\n/**\n * Get `CSSFontFaceRule` whose source is Base64 URL for all Chinese characters in a `SVGSVGElement`.\n * @param svgEl `SVGSVGElement` to be exported\n */\nexport const getBase64FontFace = (svgEl: SVGSVGElement) =>\n    fetch(\n        'https://fonts.googleapis.com/css?family=Noto+Serif+KR:600|Noto+Serif+JP:600|Noto+Serif+TC:600|Noto+Serif+SC:600%26display=swap'\n    )\n        .then(response => response.text())\n        .then(async csstext => {\n            let s = document.createElement('style');\n            s.type = 'text/css';\n            s.id = 'googlefonts';\n            s.textContent = csstext;\n            document.head.append(s);\n\n            let txt = [\n                ...new Set(\n                    [...(svgEl.querySelectorAll('.rmg-name__zh') as NodeListOf<SVGTextElement | SVGTSpanElement>)]\n                        .map(el => el.innerHTML)\n                        .join('')\n                        .replace(/[\\d\\w\\s]/g, '')\n                ),\n            ];\n\n            let rules = await Promise.all(txt.map(getRenderedFontFace));\n            s.remove();\n\n            return [...new Set(([] as string[]).concat(...rules))].map(rule =>\n                fetch(rule.match(/https:[\\w:/.-]+.woff2/g)![0])\n                    .then(response => response.blob())\n                    .then(readBlobAsDataURL)\n                    .then(uri => rule.replace(/src:[ \\w('\",\\-:/.)]+;/g, `src: url('${uri}'); `))\n                    .catch(err => {\n                        console.warn(err);\n                        return '';\n                    })\n            );\n        });\n"],"sourceRoot":""}